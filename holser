package com.open.messaging.bigbro.broker.manager;

import com.leansoft.bigqueue.BigQueueImpl;
import com.open.messaging.bigbro.broker.BigQueueTextMessage;
import com.open.messaging.bigbro.broker.dto.QueueMeta;
import java.util.Date;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.ThreadFactory;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

@Slf4j
@Data
public class QueueHolder {
  private final AtomicInteger inFlight = new AtomicInteger(0);
  private BigQueueImpl queue;
  private Date createAt = new Date();
  private Long lastMessagedPushedAt = System.currentTimeMillis();
  private QueueMeta metaData;
  private Optional<ScheduledFuture<?>> future = Optional.empty();
  private final ScheduledExecutorService scheduler;
  private final AtomicInteger currentTps = new AtomicInteger(0);
  private AtomicBoolean isEmitting = new AtomicBoolean(true);
  private QueueManager manager;

  public QueueHolder(
      BigQueueImpl queue, Date createAt, QueueMeta metaData, BigQueueManager manager) {
    super();
    this.queue = queue;
    this.metaData = metaData;
    currentTps.set(metaData.getTps());
    this.createAt = createAt;
    this.manager = manager;

    this.scheduler =
        Executors.newScheduledThreadPool(
            5,
            new ThreadFactory() {
              private final ThreadFactory defaultFactory = Executors.defaultThreadFactory();
              private final AtomicInteger count = new AtomicInteger(1);

              @Override
              public Thread newThread(Runnable r) {
                Thread t = defaultFactory.newThread(r);
                t.setName("sched-" + metaData.getName() + "-" + count.getAndIncrement());
                return t;
              }
            });
  }

  public int getPendingAcks() {
    return inFlight.get();
  }

  public void createScheduleIfnotExist() {

    int rate = currentTps.get();
    // Calculate batch size and scheduling interval
    int batchSize = rate < 1000 ? 1 : rate / 1000; // Process at least one message per millisecond
    long interval = rate < 1000 ? 1000L / rate : 1L; // Milliseconds between batches
    if (this.future.isEmpty()) {
      synchronized (metaData) {
        if (this.future.isEmpty() || this.future.get().isCancelled()) {
          log.info(
              "The scheduler will send batch of [{}] message(s) at every [{}] ms from queue [{}] have configured TPS of [{}]",
              batchSize,
              interval,
              metaData.getName(),
              rate);
          this.future =
              Optional.of(
                  scheduler.scheduleAtFixedRate(
                      () -> {
                        log.debug(
                            "Send {} batch of message from queue {}",
                            batchSize,
                            metaData.getName());

                        Flux<Integer> stream = Flux.range(0, batchSize);

                        stream
                            .flatMap(
                                messageNumber ->
                                    Mono.fromFuture(() -> dipatchAsync(messageNumber))
                                        .subscribeOn(Schedulers.boundedElastic())
                                        .doOnSubscribe(
                                            sub -> {
                                              int count = inFlight.incrementAndGet();
                                              int maxInflight =
                                                  currentTps.get() * 2 > 4000
                                                      ? 4000
                                                      : currentTps.get() * 2;
                                              if (count >= maxInflight) {
                                                isEmitting.set(false);
                                              }
                                            })
                                        .doFinally(
                                            signal -> {
                                              int maxInflight =
                                                  currentTps.get() * 2 > 4000
                                                      ? 4000
                                                      : currentTps.get() * 2;
                                              int remaining = inFlight.decrementAndGet();
                                              if (remaining < maxInflight) {
                                                isEmitting.set(true);
                                              }
                                            }),
                                batchSize)
                            .doOnComplete(
                                () -> {
                                  if (log.isDebugEnabled()) {
                                    log.debug("✅ Batch of {} messages processed", batchSize);
                                  }
                                })
                            .subscribe();
                      },
                      0,
                      interval,
                      TimeUnit.MILLISECONDS));
        }
      }
    }
  }

  private byte[] dequeue() {
    try {
      byte[] messageBytes = queue.dequeue();
      return messageBytes;
    } catch (Exception e) {
      throw new RuntimeException();
    }
  }

  private CompletableFuture<Integer> dipatchAsync(int messageNumber) {
    CompletableFuture<Integer> future = new CompletableFuture<>();

    try {
      nextConsumer(this.metaData.getName())
          .ifPresentOrElse(
              consumer -> {
                try {
                  byte[] messageBytes = dequeue();
                  if (messageBytes != null) {
                    manager.handleMessage(
                        metaData.getName(),
                        messageBytes,
                        ack -> {
                          if (!ack.isStatus()) {
                            consumer.onError();
                            if (consumer.isFaulty()) {
                              try {
                                manager.blackListListener(
                                    metaData.getName(), consumer.getConsumerId());
                              } catch (Exception e) {
                                log.warn(
                                    "Unable to blacklist faulty consumer {} of queue {}, due to {}",
                                    consumer.getConsumerId(),
                                    metaData.getName(),
                                    e.getMessage());
                              }
                            }
                          }

                          future.complete(messageNumber);
                        }, // complete when ack
                        consumer);
                  } else {
                    // no message still complete future
                    future.complete(messageNumber);
                  }

                } catch (Exception e) {
                  future.completeExceptionally(e);
                }
              },
              () -> {
                // No consumer available → complete anyway
                future.complete(messageNumber);
              });

    } catch (Exception ex) {
      future.completeExceptionally(ex);
    }
    return future;
  }

  public void cancelScheduleIfExist(String reason) {

    if (this.future.isPresent()) {
      synchronized (metaData) {
        if (this.future.isPresent()) {
          log.info(
              "Canceling fix rate schedular for queue {},due to {}", metaData.getName(), reason);
          // recoveryStaging
          this.future.get().cancel(false);
          this.future = Optional.empty();
        }
      }
    }
  }

  private boolean noMessageSinceLast1Min() {
    long fiveMinutesMillis = 1 * 60 * 1000; // 5 minutes in ms
    return (System.currentTimeMillis() - this.lastMessagedPushedAt) > fiveMinutesMillis;
  }

  public void assureDispatching(QueueMeta metaData) {
    log.debug("assureDispatching for queue " + metaData.getName());
    this.metaData.setTps(metaData.getTps());
    boolean emitting = isEmitting.get();
    ListenerHolder holder = manager.getListener(metaData.getName());
    boolean hasListeners = holder != null && holder.size() > 0;
    boolean hasMessages = queue.size() > 0;
    log.debug(
        "assureDispatching hasListeners={},hasMessages={},emitting={},noMessageSinceLast1Min={} ",
        hasListeners,
        hasMessages,
        emitting,
        noMessageSinceLast1Min());

    if (emitting && hasListeners && hasMessages) {
      // Normal case: dispatching should be active
      this.createScheduleIfnotExist();
    } else if (!emitting || !hasListeners) {
      this.cancelScheduleIfExist(!emitting ? "Consumer overloaded" : "No active listenter(s)");
    } else if (!hasMessages && noMessageSinceLast1Min()) {
      this.cancelScheduleIfExist(
          !hasMessages ? "Queue is empty" : "No message since last 5 minutes");
    }

    if (currentTps.get() != metaData.getTps()) {
      this.cancelScheduleIfExist(
          "TPS changed! from [" + currentTps.get() + "] to [" + metaData.getTps() + "]");
      this.currentTps.set(metaData.getTps());
      this.createScheduleIfnotExist(); // ensure it restarts with new TPS
    }
  }

  public Optional<NamedConsumer<BigQueueTextMessage>> nextConsumer(String queueName) {
    ListenerHolder holder = manager.getListener(metaData.getName());
    if (holder == null) {
      return Optional.empty();
    }
    return holder.nextConsumer(queueName);
  }
}